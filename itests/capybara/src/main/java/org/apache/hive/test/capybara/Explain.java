/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.hive.test.capybara;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.apache.hadoop.hive.ql.QueryPlan;
import org.apache.hadoop.hive.ql.exec.Operator;
import org.apache.hadoop.hive.ql.exec.Task;
import org.apache.hadoop.hive.ql.exec.tez.TezTask;
import org.apache.hadoop.hive.ql.plan.BaseWork;
import org.apache.hadoop.hive.ql.plan.OperatorDesc;
import org.junit.Assert;

import java.io.Serializable;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Deque;
import java.util.List;
import java.util.Set;

/**
 * Tools for working with the output of explain plan.  You should never create this directly,
 * rather it is generated by calling
 * {@link org.apache.hive.test.capybara.IntegrationTest#explain}.  This class provides tools
 * for finding particular tasks or operators in the tree, or patterns of tasks or operators.
 */
public class Explain {
  static final private Logger LOG = LoggerFactory.getLogger(Explain.class);

  final private QueryPlan plan;

  Explain(QueryPlan plan) {
    this.plan = plan;
  }

  /**
   * Get the plan for this query.
   * @return the plan.
   */
  public QueryPlan getPlan() {
    return plan;
  }

  /**
   * Doing a depth first traversal, find the first instance of the passed in Task.  If no instance
   * of this class is available Assert.fail will be called.
   * @param expectedClass class of the expected task
   * @return the first instance of the task to be found.
   */
  public <T extends Task<? extends Serializable>> T expect(Class<T> expectedClass) {
    Deque<Task<? extends Serializable>> toSearch = new ArrayDeque<>(plan.getRootTasks());
    toSearch.addLast(plan.getFetchTask());
    while (toSearch.size() > 0) {
      Task<? extends Serializable> task = toSearch.pollFirst();
      if (task.getClass().equals(expectedClass)) return (T)task;
      if (task.getChildTasks() != null) {
        for (Task<? extends Serializable> child : task.getChildTasks()) {
          toSearch.addFirst(child);
        }
      }
    }
    Assert.fail("Failed to find task of type " + expectedClass.getName());
    // I'll never get here, but it makes the compiler happy.
    return null;
  }

  /**
   * Find all instances of a given task in the tree.
   * @param lookFor class of the task we're looking for
   * @return list of all tasks of this class.  List will be empty if no tasks are found.
   */
  public <T extends Task<? extends Serializable>> List<T> findAll(Class<T> lookFor) {
    List<T> matches = new ArrayList<>();
    Deque<Task<? extends Serializable>> toSearch = new ArrayDeque<>(plan.getRootTasks());
    toSearch.addLast(plan.getFetchTask());
    while (toSearch.size() > 0) {
      Task<? extends Serializable> task = toSearch.pollFirst();
      if (task.getClass().equals(lookFor)) matches.add((T)task);
      if (task.getChildTasks() != null) {
        for (Task<? extends Serializable> child : task.getChildTasks()) {
          toSearch.addFirst(child);
        }
      }
    }
    return matches;
  }

  /**
   * Doing a depth first traversal, find the first instance of the passed in operator.  If no
   * instance of this class is found Assert.fail will be called.
   * @param task Task to look for the operator in
   * @param expectedOperator class of expected operator
   * @return the first instance of the operator to be found.
   */
  public <T extends Operator<? extends OperatorDesc>> T expect(Task<? extends Serializable> task,
                                                               Class<T> expectedOperator) {
    List<T> ops = searchForOperator(task, expectedOperator, true);
    if (ops.isEmpty()) Assert.fail("Failed to find operator of type " + expectedOperator.getName());
    else return ops.get(0);
    // Don't need this, but it makes the compiler happy.
    return null;
  }

  /**
   * Find all instances of a given operator in the task.
   * @param task Task to look for the operators in
   * @param lookFor list of all operators in the task.
   * @return list of all operators of the given class.  List will be empty if no matching
   * operators are found.
   */
  public <T extends Operator<? extends OperatorDesc>> List<T> findAll(Task task,
                                                                      Class<T> lookFor) {
    return searchForOperator(task, lookFor, false);
  }

  private <T extends Operator<? extends OperatorDesc>> List<T>
  searchForOperator(Task task, Class<T> lookFor, boolean returnFirst) {
    List<T> results = new ArrayList<>();
    Deque<Operator<? extends OperatorDesc>> toSearch = new ArrayDeque<>();
    Collection<Operator<? extends OperatorDesc>> ops = task.getTopOperators();
    if (!ops.isEmpty()) {
      toSearch.addAll(ops);
    } else if (task instanceof TezTask) { // Ok, this might be Tez
      TezTask tezTask = (TezTask)task;
      Set<BaseWork> tezRoots = tezTask.getWork().getRoots();
      if (tezRoots != null) {
        for (BaseWork root : tezRoots) {
          if (root.getAllRootOperators() != null) {
            for (Operator<? extends OperatorDesc> op : root.getAllRootOperators()) {
              toSearch.addFirst(op);
            }
          }
        }
      }
    }
    while (toSearch.size() > 0) {
      Operator<? extends OperatorDesc> op = toSearch.pollFirst();
      if (op.getClass().equals(lookFor)) {
        results.add((T)op);
        if (returnFirst) return results;
      }
      if (op.getChildOperators() != null) {
        for (Operator<? extends OperatorDesc> child : op.getChildOperators()) {
          toSearch.addFirst(child);
        }
      }
    }
    return results;
  }
}
